<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[由重构引出的State模式]]></title>
    <url>%2F2017%2F11%2F20%2FRefactor_mini_project%2F</url>
    <content type="text"><![CDATA[由重构引出的State模式： 步骤1. 先对 Customer 下手，抽出statement 2. 明确职责，分到具体的类 3. 利用查询函数 query method 来取代 totalAmount 和 frequentRentalPoints; 可以促成较为干净的设计，从而**减少冗长复杂的函数** 4. 参数是一个需要经常考虑的问题，如何尽量较少参数个数，如何尽量使参数更加的准确，而不是整一个类传过去。 5. State模式： 每个状态有着相应的行为。旋转开关 6. 无用的StringValue.Of(****); 7. 为什么要提供类型相关的行为？ [link](http://www.cnblogs.com/java-my-life/archive/2012/06/08/2538146.html) State模式 把所研究对象的行为包装在不同的 ==状态对象== 里。具体参考链接。 通过使用多态性原则，动态改变环境类Context的属性State的内容，使其从指向一个具体状态类指向另一个具体状态类，从而使环境类的行为request()由不同的具体状态类来执行。 状态和行为 所谓对象的状态，通常指的就是对象实例的属性的值；而行为指的就是对象的功能，再具体点说，行为大多可以对应到方法上。 状态模式的功能就是分离状态的行为，通过维护状态的变化，来调用不同状态对应的不同功能。也就是说，状态和行为是相关联的，它们的关系可以描述为：==状态决定行为==。 由于状态是在运行期被改变的，因此行为也会在运行期根据状态的改变而改变。 行为的平行性 注意平行线而不是平等性。所谓平行性指的是各个状态的行为所处的层次是一样的，相互独立的、没有关联的，是根据不同的状态来决定到底走平行线的哪一条。行为是不同的，当然对应的实现也是不同的，相互之间是不可替换的。 环境和状态处理对象 在状态模式中，环境(Context)是持有状态的对象，但是环境(Context)自身并不处理跟状态相关的行为，而是把处理状态的功能委托给了状态对应的状态处理类来处理。 在具体的状态处理类中经常需要获取环境(Context)自身的数据，甚至在必要的时候会回调环境(Context)的方法，因此，通常将环境(Context)自身当作一个参数传递给具体的状态处理类。 客户端一般只和环境(Context)交互。客户端可以用状态对象来配置一个环境(Context)，一旦配置完毕，就不再需要和状态对象打交道了。客户端通常不负责运行期间状态的维护，也不负责决定后续到底使用哪一个具体的状态处理对象。]]></content>
      <categories>
        <category>设计模式 重构</category>
      </categories>
      <tags>
        <tag>设计模式 重构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Algorithm introduce]]></title>
    <url>%2F2017%2F11%2F17%2Falgorithm_introduce%2F</url>
    <content type="text"><![CDATA[Algorithm introduce： 谈及数据结构需要考虑的问题：为什么要引入这种数据结构？ 逻辑结构？ 存储结构？ 时间复杂度？ 空间复杂度？ 应用 指代的就是这种数据结构产生的背景 逻辑结构 算法设计取决于逻辑结构 按照逻辑结构进行划分，常见的数结构可以分为 线性结构 和 非线性结构 线性结构 如线性表 非线性结构如 集合（数据集合）、树（一对多）、图（多对多） 另外说明：树是一种特殊的图 存储结构 算法的实现依赖于所采用的存储结构 常见的存储结构有顺序存储： 优点：随机存取； 缺点：产生碎片，不易扩容 链式存储： 优点：充分利用存储单元； 缺点：存储指针消耗额外存储空间 索引存储： 优点：检索速度极快； 缺点：消耗存储空间存储索引表 散列存储： 优点：检索、增减数据速度快； 缺点：散列函数可能存在冲突，解决冲突将消耗额外的时间和空间。 时间复杂度 理论：T(n): 算法中所有语句的频度之和，为算法规模 n 的一个函数 O(n): 为了减少无关紧要的语句对算法时间复杂度的分析，取程序最深层循环内的语句作为时间复杂度分析，根据极限理论，当 n -&gt; 正无穷时，和 T(n) 同一个数量级； 空间复杂度在存储空间白菜价格的年代，请忽略空间复杂度。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F11%2F09%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>java_group</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[突破算法第11天-红黑树]]></title>
    <url>%2F2017%2F10%2F30%2Ftesttest%2F</url>
    <content type="text"><![CDATA[突破算法第11天-红黑树： 红黑树 谈及数据结构需要考虑的问题：为什么要引入这种数据结构？ 逻辑结构？ 存储结构？ 时间复杂度？ 空间复杂度？ 应用 指代的就是这种数据结构产生的背景 逻辑结构 算法设计取决于逻辑结构 按照逻辑结构进行划分，常见的数结构可以分为 线性结构 和 非线性结构 线性结构 如线性表 非线性结构如 集合（数据集合）、树（一对多）、图（多对多） 另外说明：树是一种特殊的图 存储结构 算法的实现依赖于所采用的存储结构 常见的存储结构有顺序存储： 优点：随机存取； 缺点：产生碎片，不易扩容 链式存储： 优点：充分利用存储单元； 缺点：存储指针消耗额外存储空间 索引存储： 优点：检索速度极快； 缺点：消耗存储空间存储索引表 散列存储： 优点：检索、增减数据速度快； 缺点：散列函数可能存在冲突，解决冲突将消耗额外的时间和空间。 时间复杂度 理论：T(n): 算法中所有语句的频度之和，为算法规模 n 的一个函数 O(n): 为了减少无关紧要的语句对算法时间复杂度的分析，取程序最深层循环内的语句作为时间复杂度分析，根据极限理论，当 n -&gt; 正无穷时，和 T(n) 同一个数量级； 空间复杂度在存储空间白菜价格的年代，请忽略空间复杂度。]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[突破算法第11天-红黑树]]></title>
    <url>%2F2017%2F10%2F30%2Fmike%2F</url>
    <content type="text"><![CDATA[突破算法第11天-红黑树： 红黑树 谈及数据结构需要考虑的问题：为什么要引入这种数据结构？ 逻辑结构？ 存储结构？ 时间复杂度？ 空间复杂度？ 应用 指代的就是这种数据结构产生的背景 逻辑结构 算法设计取决于逻辑结构 按照逻辑结构进行划分，常见的数结构可以分为 线性结构 和 非线性结构 线性结构 如线性表 非线性结构如 集合（数据集合）、树（一对多）、图（多对多） 另外说明：树是一种特殊的图 存储结构 算法的实现依赖于所采用的存储结构 常见的存储结构有顺序存储： 优点：随机存取； 缺点：产生碎片，不易扩容 链式存储： 优点：充分利用存储单元； 缺点：存储指针消耗额外存储空间 索引存储： 优点：检索速度极快； 缺点：消耗存储空间存储索引表 散列存储： 优点：检索、增减数据速度快； 缺点：散列函数可能存在冲突，解决冲突将消耗额外的时间和空间。 时间复杂度 理论：T(n): 算法中所有语句的频度之和，为算法规模 n 的一个函数 O(n): 为了减少无关紧要的语句对算法时间复杂度的分析，取程序最深层循环内的语句作为时间复杂度分析，根据极限理论，当 n -&gt; 正无穷时，和 T(n) 同一个数量级； 空间复杂度在存储空间白菜价格的年代，请忽略空间复杂度。]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[突破算法第11天-红黑树]]></title>
    <url>%2F2017%2F10%2F30%2Ftest%2F</url>
    <content type="text"><![CDATA[突破算法第11天-红黑树： 红黑树 谈及数据结构需要考虑的问题：为什么要引入这种数据结构？ 逻辑结构？ 存储结构？ 时间复杂度？ 空间复杂度？ 应用 指代的就是这种数据结构产生的背景 逻辑结构 算法设计取决于逻辑结构 按照逻辑结构进行划分，常见的数结构可以分为 线性结构 和 非线性结构 线性结构 如线性表 非线性结构如 集合（数据集合）、树（一对多）、图（多对多） 另外说明：树是一种特殊的图 存储结构 算法的实现依赖于所采用的存储结构 常见的存储结构有顺序存储： 优点：随机存取； 缺点：产生碎片，不易扩容 链式存储： 优点：充分利用存储单元； 缺点：存储指针消耗额外存储空间 索引存储： 优点：检索速度极快； 缺点：消耗存储空间存储索引表 散列存储： 优点：检索、增减数据速度快； 缺点：散列函数可能存在冲突，解决冲突将消耗额外的时间和空间。 时间复杂度 理论：T(n): 算法中所有语句的频度之和，为算法规模 n 的一个函数 O(n): 为了减少无关紧要的语句对算法时间复杂度的分析，取程序最深层循环内的语句作为时间复杂度分析，根据极限理论，当 n -&gt; 正无穷时，和 T(n) 同一个数量级； 空间复杂度在存储空间白菜价格的年代，请忽略空间复杂度。]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
