<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2017%2F11%2F20%2FRefactor_mini_project%2F</url>
    <content type="text"><![CDATA[[TOC] 步骤1. 先对 Customer 下手，抽出statement 2. 明确职责，分到具体的类 3. 利用查询函数 query method 来取代 totalAmount 和 frequentRentalPoints; 可以促成较为干净的设计，从而**减少冗长复杂的函数** 4. 参数是一个需要经常考虑的问题，如何尽量较少参数个数，如何尽量使参数更加的准确，而不是整一个类传过去。 5. State模式： 每个状态有着相应的行为。旋转开关 6. 无用的StringValue.Of(****); 7. 为什么要提供类型相关的行为？ [link](http://www.cnblogs.com/java-my-life/archive/2012/06/08/2538146.html) State模式 把所研究对象的行为包装在不同的 ==状态对象== 里。具体参考链接。 通过使用多态性原则，动态改变环境类Context的属性State的内容，使其从指向一个具体状态类指向另一个具体状态类，从而使环境类的行为request()由不同的具体状态类来执行。 状态和行为 所谓对象的状态，通常指的就是对象实例的属性的值；而行为指的就是对象的功能，再具体点说，行为大多可以对应到方法上。 状态模式的功能就是分离状态的行为，通过维护状态的变化，来调用不同状态对应的不同功能。也就是说，状态和行为是相关联的，它们的关系可以描述为：==状态决定行为==。 由于状态是在运行期被改变的，因此行为也会在运行期根据状态的改变而改变。 行为的平行性 注意平行线而不是平等性。所谓平行性指的是各个状态的行为所处的层次是一样的，相互独立的、没有关联的，是根据不同的状态来决定到底走平行线的哪一条。行为是不同的，当然对应的实现也是不同的，相互之间是不可替换的。 环境和状态处理对象 在状态模式中，环境(Context)是持有状态的对象，但是环境(Context)自身并不处理跟状态相关的行为，而是把处理状态的功能委托给了状态对应的状态处理类来处理。 在具体的状态处理类中经常需要获取环境(Context)自身的数据，甚至在必要的时候会回调环境(Context)的方法，因此，通常将环境(Context)自身当作一个参数传递给具体的状态处理类。 客户端一般只和环境(Context)交互。客户端可以用状态对象来配置一个环境(Context)，一旦配置完毕，就不再需要和状态对象打交道了。客户端通常不负责运行期间状态的维护，也不负责决定后续到底使用哪一个具体的状态处理对象。 总结 对于不涉及IO操作的循环，如果有职责单一原则或者代码更加清晰的需要，可以将循环根据职责分开，会存在平衡增加了若干循环的问题，但是由于不涉及IO操作，单纯在内容中循环，这种性能问题是可以接受的。 策略模式 策略模式大多数的变化都会伴随着重复，这些重复的表现形式可能不一样，但是本质却是一样的。 在策略模式中，策略是由用户选择的，这意味着具体策略可能都要暴露给客户端，但是我们可以通过“分解依赖”来隐藏策略细节 职责角度：运费算法是另外一个层面的职责 代码角度：可维护行，可拓展性 何时使用？策略模式定义一系列的算法，并将每一个算法封装起来，而且使他们还可以相互替换。 在策略模式中，算法是其中的变化点，策略模式让算法独立于使用它的客户而独立变化。 Anyway, 不能使用多态的时候，不妨关注其中的某一个变化点，考虑采用策略模式。 重构前 重构后 后记关于策略模式与state模式的区别，后边阐述]]></content>
  </entry>
  <entry>
    <title><![CDATA[Algorithm introduce]]></title>
    <url>%2F2017%2F11%2F17%2Falgorithm_introduce%2F</url>
    <content type="text"><![CDATA[Algorithm introduce： 谈及数据结构需要考虑的问题： 为什么要引入这种数据结构？ 逻辑结构？ 存储结构？ 时间复杂度？ 空间复杂度？ 应用 指代的就是这种数据结构产生的背景 逻辑结构 算法设计取决于逻辑结构 按照逻辑结构进行划分，常见的数结构可以分为 线性结构 和 非线性结构 线性结构 如线性表 非线性结构如 集合（数据集合）、树（一对多）、图（多对多） 另外说明：树是一种特殊的图 存储结构 算法的实现依赖于所采用的存储结构 常见的存储结构有 顺序存储： 优点：随机存取； 缺点：产生碎片，不易扩容 链式存储： 优点：充分利用存储单元； 缺点：存储指针消耗额外存储空间 索引存储： 优点：检索速度极快； 缺点：消耗存储空间存储索引表 散列存储： 优点：检索、增减数据速度快； 缺点：散列函数可能存在冲突，解决冲突将消耗额外的时间和空间。 时间复杂度 理论： T(n): 算法中所有语句的频度之和，为算法规模 n 的一个函数 O(n): 为了减少无关紧要的语句对算法时间复杂度的分析，取程序最深层循环内的语句作为时间复杂度分析，根据极限理论，当 n -&gt; 正无穷时，和 T(n) 同一个数量级； 空间复杂度 在存储空间白菜价格的年代，请忽略空间复杂度。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Algorithm introduce]]></title>
    <url>%2F2017%2F11%2F17%2Fback%2Falgorithem_introduce%2F</url>
    <content type="text"><![CDATA[Algorithm introduce： 谈及数据结构需要考虑的问题：12345为什么要引入这种数据结构？逻辑结构？存储结构？时间复杂度？空间复杂度？ 应用 指代的就是这种数据结构产生的背景 逻辑结构 算法设计取决于逻辑结构 按照逻辑结构进行划分，常见的数结构可以分为 线性结构 和 非线性结构 线性结构 如线性表 非线性结构如 集合（数据集合）、树（一对多）、图（多对多） 另外说明：树是一种特殊的图 存储结构 算法的实现依赖于所采用的存储结构 常见的存储结构有1234顺序存储： 优点：随机存取； 缺点：产生碎片，不易扩容链式存储： 优点：充分利用存储单元； 缺点：存储指针消耗额外存储空间索引存储： 优点：检索速度极快； 缺点：消耗存储空间存储索引表散列存储： 优点：检索、增减数据速度快； 缺点：散列函数可能存在冲突，解决冲突将消耗额外的时间和空间。 时间复杂度 理论：12T(n): 算法中所有语句的频度之和，为算法规模 n 的一个函数O(n): 为了减少无关紧要的语句对算法时间复杂度的分析，取程序最深层循环内的语句作为时间复杂度分析，根据极限理论，当 n -&gt; 正无穷时，和 T(n) 同一个数量级； 空间复杂度1在存储空间白菜价格的年代，请忽略空间复杂度。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F11%2F09%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>java_group</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[突破算法第11天-红黑树]]></title>
    <url>%2F2017%2F10%2F30%2Ftesttest%2F</url>
    <content type="text"><![CDATA[突破算法第11天-红黑树： 红黑树 谈及数据结构需要考虑的问题：为什么要引入这种数据结构？ 逻辑结构？ 存储结构？ 时间复杂度？ 空间复杂度？ 应用 指代的就是这种数据结构产生的背景 逻辑结构 算法设计取决于逻辑结构 按照逻辑结构进行划分，常见的数结构可以分为 线性结构 和 非线性结构 线性结构 如线性表 非线性结构如 集合（数据集合）、树（一对多）、图（多对多） 另外说明：树是一种特殊的图 存储结构 算法的实现依赖于所采用的存储结构 常见的存储结构有顺序存储： 优点：随机存取； 缺点：产生碎片，不易扩容 链式存储： 优点：充分利用存储单元； 缺点：存储指针消耗额外存储空间 索引存储： 优点：检索速度极快； 缺点：消耗存储空间存储索引表 散列存储： 优点：检索、增减数据速度快； 缺点：散列函数可能存在冲突，解决冲突将消耗额外的时间和空间。 时间复杂度 理论：T(n): 算法中所有语句的频度之和，为算法规模 n 的一个函数 O(n): 为了减少无关紧要的语句对算法时间复杂度的分析，取程序最深层循环内的语句作为时间复杂度分析，根据极限理论，当 n -&gt; 正无穷时，和 T(n) 同一个数量级； 空间复杂度在存储空间白菜价格的年代，请忽略空间复杂度。]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[突破算法第11天-红黑树]]></title>
    <url>%2F2017%2F10%2F30%2Fmike%2F</url>
    <content type="text"><![CDATA[突破算法第11天-红黑树： 红黑树 谈及数据结构需要考虑的问题：为什么要引入这种数据结构？ 逻辑结构？ 存储结构？ 时间复杂度？ 空间复杂度？ 应用 指代的就是这种数据结构产生的背景 逻辑结构 算法设计取决于逻辑结构 按照逻辑结构进行划分，常见的数结构可以分为 线性结构 和 非线性结构 线性结构 如线性表 非线性结构如 集合（数据集合）、树（一对多）、图（多对多） 另外说明：树是一种特殊的图 存储结构 算法的实现依赖于所采用的存储结构 常见的存储结构有顺序存储： 优点：随机存取； 缺点：产生碎片，不易扩容 链式存储： 优点：充分利用存储单元； 缺点：存储指针消耗额外存储空间 索引存储： 优点：检索速度极快； 缺点：消耗存储空间存储索引表 散列存储： 优点：检索、增减数据速度快； 缺点：散列函数可能存在冲突，解决冲突将消耗额外的时间和空间。 时间复杂度 理论：T(n): 算法中所有语句的频度之和，为算法规模 n 的一个函数 O(n): 为了减少无关紧要的语句对算法时间复杂度的分析，取程序最深层循环内的语句作为时间复杂度分析，根据极限理论，当 n -&gt; 正无穷时，和 T(n) 同一个数量级； 空间复杂度在存储空间白菜价格的年代，请忽略空间复杂度。]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[突破算法第11天-红黑树]]></title>
    <url>%2F2017%2F10%2F30%2Ftest%2F</url>
    <content type="text"><![CDATA[突破算法第11天-红黑树： 红黑树 谈及数据结构需要考虑的问题：为什么要引入这种数据结构？ 逻辑结构？ 存储结构？ 时间复杂度？ 空间复杂度？ 应用 指代的就是这种数据结构产生的背景 逻辑结构 算法设计取决于逻辑结构 按照逻辑结构进行划分，常见的数结构可以分为 线性结构 和 非线性结构 线性结构 如线性表 非线性结构如 集合（数据集合）、树（一对多）、图（多对多） 另外说明：树是一种特殊的图 存储结构 算法的实现依赖于所采用的存储结构 常见的存储结构有顺序存储： 优点：随机存取； 缺点：产生碎片，不易扩容 链式存储： 优点：充分利用存储单元； 缺点：存储指针消耗额外存储空间 索引存储： 优点：检索速度极快； 缺点：消耗存储空间存储索引表 散列存储： 优点：检索、增减数据速度快； 缺点：散列函数可能存在冲突，解决冲突将消耗额外的时间和空间。 时间复杂度 理论：T(n): 算法中所有语句的频度之和，为算法规模 n 的一个函数 O(n): 为了减少无关紧要的语句对算法时间复杂度的分析，取程序最深层循环内的语句作为时间复杂度分析，根据极限理论，当 n -&gt; 正无穷时，和 T(n) 同一个数量级； 空间复杂度在存储空间白菜价格的年代，请忽略空间复杂度。]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
